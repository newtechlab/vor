package main

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	mrand "math/rand"
	"strings"

	"github.com/newtechlab/vor/vorgen/config"
	"github.com/newtechlab/vor/vorgen/twillio"
)

func generateTwillioProject(c config.Config) (p *twillio.Project) {
	p = &twillio.Project{
		Description: "Project generated by vorgen",
		States:      []twillio.State{},
	}

	// in order to populate the next fields we build from the back
	next := make([]string, c.NumberVariations)
	for i := range next {
		next[i] = generateSequence(p, c, 2600*i, 400, i)
	}
	generateStaticPart(p, c, next)

	// Since twillio apparently is sensitive to the order in the
	// json file, reverse it..
	for i, j := 0, len(p.States)-1; i < j; i, j = i+1, j-1 {
		p.States[i], p.States[j] = p.States[j], p.States[i]
	}

	return
}

func generateSequence(p *twillio.Project, c config.Config, ox, oy int, no int) string {
	// iterate the threads in random order so we
	// can create multiple non overlapping
	le := 1
	for _, t := range c.Threads {
		for range t {
			le++
		}
	}
	nextFirst := ""
	for _, i := range generatePerm(c) {
		for ii := range c.Threads[i] {
			question := c.Threads[i][len(c.Threads[i])-1-ii]
			le--
			vals := []string{}
			for j := 1; j <= le; j++ {
				vals = append(vals, fmt.Sprintf("{{widgets.ans_%v_%v.RecordingUrl}}", no, j))
			}

			s1 := createPlay(c, 2060+ox, 710+300*le+oy, fmt.Sprintf("play_%v_%v", no, le), c.ThanksMessage, nil)
			p.Add(s1)

			s2 := createWebhook(c, 1700+ox, 710+300*le+oy,
				fmt.Sprintf("send_data_%v_%v", no, le), strings.Join(vals, ","),
				&s1.Sid,
			)
			p.Add(s2)

			nf := nextFirst
			if nf == "" {
				nf = s2.Sid
			}
			s3 := createSplit(c, 1250+ox, 710+300*le+oy, fmt.Sprintf("split_%v_%v", no, le), fmt.Sprintf("{{ widgets.set_variables_%v_%v.time }}", no, le), nf, "greater_than", fmt.Sprint(c.DesiredTime), s2.Sid)
			p.Add(s3)

			setstr := fmt.Sprintf("{{ widgets.ans_%v_%v.RecordingDuration | plus: widgets.set_variables_%v_%v.time }}", no, le, no, le-1)
			if le == 1 {
				setstr = fmt.Sprintf("{{ widgets.ans_%v_%v.RecordingDuration | plus: widgets.set_variables_00.time }}", no, le)
			}
			s4 := createSetVariables(c, 880+ox, 710+300*le+oy, fmt.Sprintf("set_variables_%v_%v", no, le), setstr, &s3.Sid)
			p.Add(s4)

			s5 := createRecord(c, 520+ox, 710+300*le+oy, fmt.Sprintf("ans_%v_%v", no, le), &s4.Sid)
			p.Add(s5)

			s6 := createPlay(c, 160+ox, 710+300*le+oy, fmt.Sprintf("question_%v_%v", no, le), question, &s5.Sid)
			p.Add(s6)

			nextFirst = s6.Sid
		}
	}
	return nextFirst
}

func generateStaticPart(p *twillio.Project, c config.Config, next []string) {
	sa := createPlay(c, -380, 490, "abort", c.StartMessageBadReply, nil)
	p.Add(sa)

	args := make([]string, 0, 0*3*len(next))

	for i := range next {
		args = append(args,
			"equal_to",
			fmt.Sprint(i),
			next[i],
		)
	}

	s1 := createSplit(c, -120, 940, "split_path", "{{ widgets.set_variables_path.time }}", sa.Sid, args...)
	p.Add(s1)

	s2 := createSetVariables(c, 0, 700, "set_variables_path", "{{ trigger.call.CallSid | replace:'a','' | replace:'CA','' | replace:'b','' | replace:'c','' | replace:'d','' | replace:'e','' | replace:'f','' | slice: -3, 3 | modulo: "+fmt.Sprint(len(next))+"  }}", &s1.Sid)
	p.Add(s2)

	s3 := createSetVariables(c, 0, 490, "set_variables_00", "0", &s2.Sid)
	p.Add(s3)

	s4 := createSplit(c, -280, 260, "split_1", "{{widgets.gather_1.SpeechResult}}", sa.Sid, "contains", c.StartMessageReply, s3.Sid)
	p.Add(s4)

	s5 := createGather(c, -480, 40, "gather_1", &s4.Sid)
	p.Add(s5)

	s6 := createInitialState(c, -740, -140, &s5.Sid)
	p.Add(s6)
}

func createWebhook(c config.Config, x, y int, name, value string, next *string) twillio.State {
	p := createProps(x, y,
		"method", "POST",
		"url", c.Webhook,
		"body", nil,
		"timeout", nil,
		"parameters", []map[string]interface{}{{
			"key":   "urls",
			"value": value,
			"index": 0,
		},
			{
				"key":   "phone",
				"value": "{{trigger.call.From}}",
			},
		},
		"save_response_as", nil,
		"content_type", "application/x-www-form-urlencoded;charset=utf-8",
	)
	ts := []twillio.Transition{
		createTransition("success", next, []twillio.Condition{}),
		createTransition("failed", nil, []twillio.Condition{}),
	}
	return createState("Webhook", name, p, ts)
}

func createSplit(c config.Config, x, y int, name, input string, noMatchNext string, strs ...string) twillio.State {

	if len(strs)%3 != 0 {
		panic("expected triplets of mtype, value, next")
	}

	p := createProps(x, y,
		"input", input,
	)
	ts := []twillio.Transition{
		createTransition("noMatch", &noMatchNext,
			[]twillio.Condition{})}
	for i := 0; i < len(strs); i += 3 {
		mtype, value, next := strs[i], strs[i+1], strs[i+2]
		ts = append(ts, createTransition("match", &next,
			[]twillio.Condition{{
				"friendly_name": "If value " + mtype,
				"type":          mtype,
				"arguments":     []string{input},
				"value":         value,
			}}))
	}

	return createState("Branch", name, p, ts)
}

func createTransition(event string, next *string, conditions []twillio.Condition) twillio.Transition {
	ts := twillio.Transition{
		Event:      twillio.Event(event),
		Next:       next,
		Conditions: conditions,
		UUID:       generateUUID(),
	}
	return ts
}

func createSetVariables(c config.Config, x, y int, name, value string, next *string) twillio.State {
	p := createProps(x, y,
		"variables", []map[string]interface{}{{
			"key":   "time",
			"value": value,
			"index": 0,
		}},
	)
	ts := []twillio.Transition{
		createTransition("next", next,
			[]twillio.Condition{}),
	}
	return createState("SetVariables", name, p, ts)
}

func createGather(c config.Config, x, y int, name string, next *string) twillio.State {
	p := createProps(x, y,
		"timeout", 5,
		"finish_on_key", "#",
		"stop_gather", true,
		"save_response_as", nil,
		"say", c.StartMessage,
		"play", nil,
		"voice", "default",
		"language", c.Lang,
		"loop", 1,
		"gather_language", c.Lang,
		"hints", "yes,no",
	)
	ts := []twillio.Transition{
		createTransition("speech", next,
			[]twillio.Condition{}),
		createTransition("keypress", next,
			[]twillio.Condition{}),
		createTransition("timeout", next,
			[]twillio.Condition{}),
	}
	return createState("Gather", name, p, ts)
}

func createPlay(c config.Config, x, y int, name, msg string, next *string) twillio.State {
	p := createProps(x, y,
		"say", msg,
		"play", nil,
		"voice", "default",
		"language", c.Lang,
		"loop", 1,
	)
	ts := []twillio.Transition{
		createTransition("audioComplete", next,
			[]twillio.Condition{}),
	}
	return createState("SayPlay", name, p, ts)
}

func createRecord(c config.Config, x, y int, name string, next *string) twillio.State {
	p := createProps(x, y,
		"timeout", c.SilenceTimeout,
		"finish_on_key", nil,
		"max_length", 3600,
		"transcribe", nil,
		"transcription_callback_url", nil,
	)
	ts := []twillio.Transition{
		createTransition(
			"recordingComplete", next,
			[]twillio.Condition{},
		),
		createTransition(
			"noAudio", next,
			[]twillio.Condition{},
		),
		createTransition(
			"hangup", nil,
			[]twillio.Condition{},
		),
	}
	return createState("Record", name, p, ts)
}
func createInitialState(c config.Config, x, y int, next *string) twillio.State {
	name := "Trigger"
	p := createProps(x, y)
	ts := []twillio.Transition{
		createTransition("incomingMessage", nil,
			[]twillio.Condition{}),
		createTransition("incomingCall", next,
			[]twillio.Condition{}),
		createTransition("incomingRequest", nil,
			[]twillio.Condition{}),
	}
	st := createState("InitialState", name, p, ts)
	return st
}

func createState(typ, name string, p twillio.Properties, ts []twillio.Transition) twillio.State {
	if ts == nil {
		ts = []twillio.Transition{}
	}
	sid := generateSid()
	for i := range ts {
		ts[i].WidgetID = sid
	}
	s := twillio.State{
		Type:        typ,
		Name:        name,
		Sid:         sid,
		Properties:  p,
		Transitions: ts,
	}
	return s
}

func createProps(x, y int, args ...interface{}) twillio.Properties {
	p := twillio.Properties{
		"offset": map[string]int{
			"x": x,
			"y": y,
		},
	}
	if len(args)%2 != 0 {
		panic("must have pair of 2s")
	}
	for i := 0; i < len(args); i += 2 {
		str, ok := args[i].(string)
		if !ok {
			panic("all the keys must be strings")
		}
		p[str] = args[i+1]
	}
	return p
}

func generateSid() string {
	buf := make([]byte, 16)
	n, err := rand.Read(buf)
	if n != 16 {
		panic("could not read random data " + err.Error())
	}
	return "FF" + hex.EncodeToString(buf)
}

func generateUUID() string {
	buf := make([]byte, 16)
	n, err := rand.Read(buf)
	if n != 16 {
		panic("could not read random data " + err.Error())
	}
	return hex.EncodeToString(buf[0:4]) + "-" + hex.EncodeToString(buf[4:6]) + "-" + hex.EncodeToString(buf[6:8]) + "-" + hex.EncodeToString(buf[8:10]) + "-" + hex.EncodeToString(buf[10:])
}

func generatePerm(c config.Config) []int {
	return mrand.Perm(len(c.Threads))
}
